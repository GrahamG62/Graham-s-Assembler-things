         MACRO
         KEYW  &level,             . Level                             +
               &word,              . Text                              +
               &len=,              . Length (min,max)                  +
               &mult=N,            . Allow multiple operands           +
               &pre=,              . Preprocess routine address        +
               &post=              . Postprocess routine address

         gblc  &next(99),          . Next word at this level           +
               &nend(99),          . End label at next level           +
               &curr(99),          . Word at current level             +
               &root(99),          . Root at current level             +
               &nxto               . Operand at current level
         gbla  &kvect,             . Keyword vector                    +
               &svect,             . Structure vector                  +
               &ovect              . Operand vector

         lclb  &f1(8),&f2(8),&f3(8),&f4(8)  . flag bytes

&ulev    setc  (upper '&level')
         aif   ('&ulev' eq 'DSECT').dsct000
         aif   ('&ulev' ne 'END').term000

.*     *--------------------------------------------------------------*
.*     * END - Terminate all levels                                   *
.*     *--------------------------------------------------------------*
&s       seta  0
         ago   .term010            . And terminate

.*     *--------------------------------------------------------------*
.*     * Terminate higher levels                                      *
.*     *--------------------------------------------------------------*
.term000 anop
&s       seta  &level              . Set current level
.term010 anop
&l       seta  99

         aif   ('&nxto' eq '').term020 . Skip if no operands

         mnote *,'-------------------------------------------------- *'
         mnote *,' Terminate operands                                 '
         mnote *,'-------------------------------------------------- *'
&nxto    dc    xl1'10'             * End of operands
&nxto    setc  ''                  . Clear &nxto
&ovect   seta  0                   . Initialise operand vector

.term020 anop
         aif   (&l eq &s).term900
         aif   ('&curr(&l)' eq '').term030

&labc    setc  '&next(&l)'
         mnote *,'-------------------------------------------------- *'
         mnote *,' Terminate level &l                                 '
         mnote *,'-------------------------------------------------- *'
&labc    dc    xl1'40'             * Terminate level
         dc    al1(&l)             * Level

&curr(&l) setc ''                  . Clear ...
&nend(&l) setc ''                  . ...
&next(&l) setc ''                  . ... level info

.term030 anop
&l       seta  &l-1                . Decrement level pointer
         ago   .term020            . And loop
.term900 anop

.*     *--------------------------------------------------------------*
.*     * Exit if END                                                  *
.*     *--------------------------------------------------------------*
         aif   ('&ulev' ne 'END').levl000
         mexit

.*     *--------------------------------------------------------------*
.*     * Start new level                                              *
.*     *--------------------------------------------------------------*
.levl000 anop
         aif   ('&next(&level)' ne '').levl010  . 1st at this level?
&labc    setc  '#ks&sysndx'                     . Yes, initial label
&labe    setc  '#kt&sysndx'                     . ...  initial label
&root(&level)  setc '&labc'                     . Set root
         ago   .levl020

.levl010 anop
&labc    setc  '&next(&level)'             . Get next label
&labe    setc  '&nend(&level)'             . Get next end label

.levl020 anop
&labn    setc '#kn&sysndx'                 . Set new next label
&next(&level) setc '&labn'                 . Save for next iteration
&nend(&level) setc '#ke&sysndx'            . Set next end label

         aif   ('&curr(&level)' ne '').levl030  . Got prev at level?
&labp    setc  '0'                              . No, set address 0
         ago   .levl040

.levl030 anop
&labp    setc '&curr(&level)'         . Set previous entry

.levl040 anop
&curr(&level) setc '&labc'            . Set as current entry
         aif   (&level gt 1).levl050  . Is this level 1?
&labh    setc  '0'                    . Yes, no root level
&svect   seta  0                      . Initialise structure vector
         ago   .levl900

.levl050 anop                      . Set root level for this entry
&l       seta  &level-1            . Go back to previous level
&labh    setc  '&root(&l)'         . Get root entry at lower level

.levl900 anop                      . End of level section

.*     *--------------------------------------------------------------*
.*     * Isolate keyword                                              *
.*     *--------------------------------------------------------------*
.word000 anop
         aif   (t'&word ne 'O').word020
&minl    seta  0                   . Min length = 0
&maxl    seta  0                   . Max length = 0
&rfac    setc  '0c'                . Length of field = 0
&kwrd    setc  ''                  . Keyword
         ago   .word900            . Done this word !

.word020 anop
         aif   ('&word'(1,1) eq '''').word030
         mnote 8,'Keyw - keyword &word invalid'
         mexit

.word030 anop
         aif   ('&word'(k'&word,1) eq '''').word040
         mnote 8,'Keyw - keyword &word invalid'
         mexit

.word040 anop
&kwrd    setc  '&word'(2,k'&word-2)    . Isolate word
&wlen    seta  k'&word-2               . Get word length
.*&rlen    seta  ((&wlen+3)/4)*4         . Round up length to f'wrd
.*&rfac    setc  'cl&rlen'               . Set dc info
&rfac    setc  'cl&wlen'               . Set dc info
&f1(1)   setb  1                       . Show word supplied

.word900 anop                      . End of word section

.*     *--------------------------------------------------------------*
.*     * Process min. max lengths                                     *
.*     *--------------------------------------------------------------*
.lenf000 anop
         aif   (t'&word eq 'O').lenf100 . No word, skip
         aif   (t'&len ne 'O').lenf010  . Len= provided, go process

&minl    seta  &wlen               . Set min length
&maxl    seta  &wlen               . Set max length
         ago   .lenf900            . And we're done here!

.*     *--------------------------------------------------------------*
.*     * Len= supplied with word                                      *
.*     *--------------------------------------------------------------*
.lenf010 anop
&minl    seta  &wlen               . Set min length
&maxl    seta  &wlen               . Set max length

         aif   (n'&len gt 2).lenf800
         aif   (t'&len(1) eq 'O').lenf020
         aif   (&len(1) gt &wlen).lenf820

&minl    seta  &len(1)             . Set min length
&f1(2)   setb  1                   . Set Explicit min length

.lenf020 anop
         aif   (t'&len(2) eq 'O').lenf900
         aif   (&len(2) gt &wlen).lenf820

&maxl    seta  &len(2)             . Set max length
&f1(3)   setb  1                   . Set Explicit max length
         ago   .lenf900            . And we're done here!

.*     *--------------------------------------------------------------*
.*     * Len= supplied on its own                                     *
.*     *--------------------------------------------------------------*
.lenf100 anop
         aif   (n'&len gt 2).lenf800

&minl    seta  0                   . Set min length
&maxl    seta  0                   . Set max length
         aif   (t'&len(1) eq 'O').lenf120
&minl    seta  &len(1)             . Set min length
&f1(2)   setb  1                   . Set Explicit min length

.lenf120 anop
         aif   (t'&len(2) eq 'O').lenf900

&maxl    seta  &len(2)             . Set max length
&f1(3)   setb  1                   . Set Explicit max length
         ago   .lenf900            . And we're done here!

.lenf800 anop
         mnote 8,'Keyw - length is (min,max)'
         mexit

.lenf810 anop
         mnote 8,'Keyw - min length greater than word length'
         mexit

.lenf820 anop
         mnote 8,'Keyw - max length greater than word length'
         mexit

.lenf900 anop                      . End of length section

.*     *--------------------------------------------------------------*
.*     * Allow multiple operands ?                                    *
.*     *--------------------------------------------------------------*
.mult000 anop
&umlt    setc  (upper '&mult')     . Upper-case mult=...
         aif   ('&umlt' ne 'Y').genr000
         aif   (&f1(1) eq 0).mult010
         mnote 8,'Keyw - mult=Y is incompatable with keyword'
         mexit

.mult010 anop
&f1(4)   setb  1                   . Set multiple operand flag
         ago   .genr000


.*     *--------------------------------------------------------------*
.*     * Generate table entry                                         *
.*     *--------------------------------------------------------------*
.genr000 anop

 mnote *,'----------------------------------------------------- *'
 mnote *,' Keyword &kwrd at level &level, Vector(&kvect,&svect)  '
 mnote *,'----------------------------------------------------- *'
&labc    dc    xl1'80'             * Flag = keyword
         dc    al1(&level)         * Current level
         dc    bl1'&f1(1)&f1(2)&f1(3)&f1(4)&f1(5)&f1(6)&f1(7)&f1(8)'
         dc    al1(&svect)         * Current Structure vector
         dc    al4(&labn)          * Next entry at current level
.*       dc    al4(&labp)          * Previous entry at current level
         dc    al4(&labh)          * Root keyword at lower level
         dc    al2(&kvect)         * Current Keyword vector
         dc    al2(&labe)          * Keyword entry length
         dc    al1(&minl)          * Minimum length
         dc    al1(&maxl)          * Maximum length
         dc    &rfac.&word         * Keyword
&labe    equ   *-&labc             * Length of this keyword entry

&kvect   seta  &kvect+1            . Increment vector value
&svect   seta  &svect+1            . Increment vector value
         mexit

.*     *--------------------------------------------------------------*
.*     * Map table entry                                              *
.*     *--------------------------------------------------------------*
.dsct000 anop
keyw     dsect ,
kwid     ds    xl1                 * Entry flag
kwkey    equ   kwid,x'80'          *   This is a keyword
kwend    equ   kwid,x'40'          *   End of level
kwlvl    ds    al1                 * Level
kwflg1   ds    xl1                 * Flag#1
kwf1wd   equ   kwflg1,x'80'        *   Word supplied in table
kwf1mn   equ   kwflg1,x'40'        *   Explicit minimum supplied
kwf1mx   equ   kwflg1,x'20'        *   Explicit maximum supplied
kwf1mo   equ   kwflg1,x'10'        *   Allow multiple operands
kwsvct   ds    al1                 * Structure Vector
kwnxt    ds    al4                 * Next keyword at current level
.*kwprv    ds    al4               * Previous keyword at current level
kwroot   ds    al4                 * Root keyword at previous level
kwvct    ds    al2                 * Keyword Vector
kwelen   ds    al2                 * Length of this table entry
kwmin    ds    al1                 * Minimun length of keyword
kwlen    ds    al1                 * Maximum (actual) length of keyword
kwword   ds    0c                  * The keyword
         MEND
